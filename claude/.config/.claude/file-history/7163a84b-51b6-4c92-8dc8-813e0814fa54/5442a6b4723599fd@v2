import { Webhooks } from "@polar-sh/sveltekit";
import { db } from "@/db/server";
import { user as userSchema } from "@/db/server/schema.server";
import { eq } from "drizzle-orm";
import { randomBytes } from "crypto";
import { sendActivationEmail } from "@/email/activation.service";

async function createUserFromSubscription(payload: any) {
  const customer = payload.data.customer;
  const subscription = payload.data;
  
  if (!customer || !customer.email) {
    console.error("No customer email found in subscription payload");
    return;
  }

  try {
    // Check if user already exists
    const existingUser = await db
      .select()
      .from(userSchema)
      .where(eq(userSchema.email, customer.email))
      .limit(1);

    if (existingUser.length > 0) {
      console.log("User already exists for email:", customer.email);
      
      // Update existing user with subscription info
      await db
        .update(userSchema)
        .set({
          polar_customer_id: customer.id,
          subscription_status: subscription.status,
          current_period_end: subscription.current_period_end ? new Date(subscription.current_period_end) : null,
          updatedAt: new Date(),
        })
        .where(eq(userSchema.email, customer.email));
      
      return existingUser[0];
    }

    // Generate activation token
    const activationToken = randomBytes(32).toString('hex');

    // Create new user
    const newUser = await db
      .insert(userSchema)
      .values({
        id: randomBytes(16).toString('hex'),
        email: customer.email,
        name: customer.name || customer.email.split('@')[0],
        emailVerified: false,
        polar_customer_id: customer.id,
        subscription_status: subscription.status,
        activation_token: activationToken,
        current_period_end: subscription.current_period_end ? new Date(subscription.current_period_end) : null,
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();

    console.log("Created new user:", newUser[0]);

    // Send activation email with magic link
    await sendActivationEmail(customer.email, activationToken);

    return newUser[0];
  } catch (error) {
    console.error("Error creating user from subscription:", error);
    throw error;
  }
}

async function updateSubscriptionStatus(customerId: string, status: string) {
  try {
    await db
      .update(userSchema)
      .set({
        subscription_status: status,
        updatedAt: new Date(),
      })
      .where(eq(userSchema.polar_customer_id, customerId));

    console.log(`Updated subscription status to ${status} for customer ${customerId}`);
  } catch (error) {
    console.error("Error updating subscription status:", error);
    throw error;
  }
}

export const POST = Webhooks({
  webhookSecret: process.env.POLAR_WEBHOOK_SECRET!,
  onPayload: async (payload) => {
    // Handle the payload
    console.log("Webhook payload received:", {
      type: payload.type,
      data: payload.data
    });
  },
  onSubscriptionActive: async (payload) => {
    console.log("Subscription activated:", payload.data);
    await createUserFromSubscription(payload);
  },
  onSubscriptionCreated: async (payload) => {
    console.log("Subscription created:", payload.data);
    // Note: We wait for 'active' status, not just creation
  },
  onSubscriptionUpdated: async (payload) => {
    console.log("Subscription updated:", payload.data);
    const subscription = payload.data;
    if (subscription.customer && subscription.customer.id) {
      await updateSubscriptionStatus(subscription.customer.id, subscription.status);
    }
  },
  onSubscriptionCanceled: async (payload) => {
    console.log("Subscription canceled:", payload.data);
    const subscription = payload.data;
    if (subscription.customer && subscription.customer.id) {
      await updateSubscriptionStatus(subscription.customer.id, "canceled");
    }
  },
  onSubscriptionRevoked: async (payload) => {
    console.log("Subscription revoked:", payload.data);
    const subscription = payload.data;
    if (subscription.customer && subscription.customer.id) {
      await updateSubscriptionStatus(subscription.customer.id, "revoked");
    }
  },
  onOrderPaid: async (payload) => {
    console.log("Order paid:", payload.data);
    // Handle one-time purchases if needed
  },
});

// onPayload - Catch-all handler for any incoming Webhook event
// onCheckoutCreated - Triggered when a checkout is created
// onCheckoutUpdated - Triggered when a checkout is updated
// onOrderCreated - Triggered when an order is created
// onOrderPaid - Triggered when an order is paid
// onOrderRefunded - Triggered when an order is refunded
// onRefundCreated - Triggered when a refund is created
// onRefundUpdated - Triggered when a refund is updated
// onSubscriptionCreated - Triggered when a subscription is created
// onSubscriptionUpdated - Triggered when a subscription is updated
// onSubscriptionActive - Triggered when a subscription becomes active
// onSubscriptionCanceled - Triggered when a subscription is canceled
// onSubscriptionRevoked - Triggered when a subscription is revoked
// onSubscriptionUncanceled - Triggered when a subscription cancellation is reversed
// onProductCreated - Triggered when a product is created
// onProductUpdated - Triggered when a product is updated
// onOrganizationUpdated - Triggered when an organization is updated
// onBenefitCreated - Triggered when a benefit is created
// onBenefitUpdated - Triggered when a benefit is updated
// onBenefitGrantCreated - Triggered when a benefit grant is created
// onBenefitGrantUpdated - Triggered when a benefit grant is updated
// onBenefitGrantRevoked - Triggered when a benefit grant is revoked
// onCustomerCreated - Triggered when a customer is created
// onCustomerUpdated - Triggered when a customer is updated
// onCustomerDeleted - Triggered when a customer is deleted
// onCustomerStateChanged - Triggered when a customer state changes
