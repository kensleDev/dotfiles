#!/usr/bin/env bun

/**
 * CLI Quest - Learn command-line tools through interactive challenges
 *
 * A modular game that teaches fd, sed, awk, jq, and rsync through
 * realistic development scenarios.
 */

import * as readline from 'readline';
import { GameState, Tool } from './types';
import { challengesByTool, getUnlockedTools, getChallengesForTool } from './challenges';
import { StateManager } from './game/StateManager';
import { Display } from './game/Display';
import { ChallengeRunner } from './game/ChallengeRunner';
import { setupFdChallenge1, setupSedChallenge1 } from './game/Utils';

class CLIQuest {
  private state: GameState;

  constructor() {
    this.state = StateManager.loadState();
  }

  async start() {
    Display.showBanner();
    console.log(`Welcome to CLI Quest!`);
    console.log(`\nYou'll learn fd, sed, awk, jq, and rsync through real scenarios.`);
    console.log(`Each challenge simulates actual development tasks.\n`);
    console.log(`Press Enter to start...`);

    const rl = Display.createReadlineInterface();

    await new Promise<void>((resolve) => {
      rl.question('', () => {
        rl.close();
        resolve();
      });
    });

    await this.runToolSelection();
  }

  private async runToolSelection() {
    while (true) {
      Display.showToolSelection(this.state);

      const rl = Display.createReadlineInterface();

      const result = await new Promise<'tool' | 'status' | 'exit' | null>((resolve) => {
        rl.prompt();

        rl.on('line', (input: string) => {
          const command = input.trim().toLowerCase();

          switch (command) {
            case '1':
            case '2':
            case '3':
            case '4':
            case '5': {
              const toolIndex = parseInt(command) - 1;
              const unlockedTools = getUnlockedTools();
              if (toolIndex < unlockedTools.length) {
                const selectedTool = unlockedTools[toolIndex];
                this.state.currentTool = selectedTool;
                this.state.currentChallengeInTool = this.state.toolProgress[selectedTool];
                StateManager.saveState(this.state);
                rl.close();
                resolve('tool');
              } else {
                console.log(`\nâŒ Tool not unlocked yet! Complete previous challenges to unlock.\n`);
                rl.prompt();
              }
              break;
            }

            case 'status':
              Display.showProgress(this.state);
              rl.prompt();
              break;

            case 'exit':
              console.log(`\nðŸ‘‹ Progress saved. Run the game again to continue!\n`);
              rl.close();
              resolve('exit');
              break;

            default:
              console.log(`\nâš ï¸ Unknown command. Try: 1-5, status, or exit\n`);
              rl.prompt();
              break;
          }
        });

        rl.on('close', () => {
          resolve(null);
        });
      });

      if (result === 'exit') {
        break;
      } else if (result === 'tool') {
        await this.runCurrentTool();
      }
    }
  }

  private async runCurrentTool() {
    const currentTool = this.state.currentTool;
    if (!currentTool) return;

    const toolChallenges = getChallengesForTool(currentTool);
    const startingChallengeIndex = this.state.currentChallengeInTool;

    // Check if tool is complete
    if (startingChallengeIndex >= toolChallenges.length) {
      Display.showToolComplete(currentTool);
      this.state.currentTool = null;
      StateManager.saveState(this.state);
      await new Promise(resolve => setTimeout(resolve, 3000));
      return;
    }

    // Run challenges from current position
    for (let i = startingChallengeIndex; i < toolChallenges.length; i++) {
      const challenge = toolChallenges[i];

      // Set up challenge-specific environment
      if (currentTool === 'fd' && i === 0) {
        challenge.setup = setupFdChallenge1;
      } else if (currentTool === 'sed' && i === 0) {
        challenge.setup = setupSedChallenge1;
      }

      const result = await ChallengeRunner.runChallenge(challenge, this.state);

      if (result === 'exit') {
        return;
      }

      // Update current challenge position
      this.state.currentChallengeInTool = i + 1;
      StateManager.saveState(this.state);

      // Check if tool is complete
      if (this.state.toolProgress[currentTool] >= toolChallenges.length) {
        Display.showToolComplete(currentTool);
        await new Promise(resolve => setTimeout(resolve, 3000));
        this.state.currentTool = null;
        StateManager.saveState(this.state);
        break;
      }
    }
  }
}

// Main entry point
async function main() {
  try {
    const game = new CLIQuest();
    await game.start();
    StateManager.cleanup();
  } catch (error) {
    console.error('Error running CLI Quest:', error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGINT', () => {
  console.log('\n\nðŸ‘‹ Game saved. Thanks for playing!');
  StateManager.cleanup();
  process.exit(0);
});

if (require.main === module) {
  main();
}