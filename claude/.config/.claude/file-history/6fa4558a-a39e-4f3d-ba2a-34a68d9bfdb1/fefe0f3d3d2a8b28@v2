import { GameState as GameStateType } from './Challenge';
import * as fs from 'fs';
import * as path from 'path';

export class StateManager {
  private static readonly STATE_FILE = path.join(process.cwd(), '.cli-quest-state.json');

  static loadState(): GameStateType {
    if (fs.existsSync(this.STATE_FILE)) {
      try {
        return JSON.parse(fs.readFileSync(this.STATE_FILE, 'utf-8'));
      } catch {
        return this.createNewState();
      }
    }
    return this.createNewState();
  }

  static createNewState(): GameStateType {
    return {
      currentTool: null,
      currentChallengeInTool: 0,
      completedChallenges: [],
      unlockedTools: ['fd'], // fd is always unlocked
      hintsUsed: {},
      startTime: Date.now(),
      toolProgress: {
        fd: 0,
        sed: 0,
        awk: 0,
        jq: 0,
        rsync: 0
      }
    };
  }

  static saveState(state: GameStateType) {
    fs.writeFileSync(this.STATE_FILE, JSON.stringify(state, null, 2));
  }

  static resetState() {
    const newState = this.createNewState();
    this.saveState(newState);
    return newState;
  }

  static cleanup() {
    const gameDir = path.join(process.cwd(), '.cli-quest-game');
    if (fs.existsSync(gameDir)) {
      fs.rmSync(gameDir, { recursive: true, force: true });
    }
  }
}

export function createDir(dir: string) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

export function writeFile(filepath: string, content: string) {
  const dir = path.dirname(filepath);
  createDir(dir);
  fs.writeFileSync(filepath, content);
}

export function readFile(filepath: string): string {
  return fs.readFileSync(filepath, 'utf-8');
}

export function fileExists(filepath: string): boolean {
  return fs.existsSync(filepath);
}

export function countOccurrences(filepath: string, pattern: string): number {
  if (!fileExists(filepath)) return 0;
  const content = readFile(filepath);
  const matches = content.match(new RegExp(pattern, 'g'));
  return matches ? matches.length : 0;
}